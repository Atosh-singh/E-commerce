Project

Parsing incoming request

Validating user input

NPM repository- that is a cloud package repository

Third party package that helps us to save automatically without restarting our server---
for this autostart maechanism package called == nodemon
npm install nodemon

Packages which you install can be divided into development packages, so packages which mostly helps you during development and production dependencies
so packages that helps you for the app as it's running on a server,

nodemon would be a development dependency because we only use it during development process

npm install nodemon --save      = this would install it as a production dependency
npm install nodemon --save-dev  = this only adds something we used during development
npm install nodemon -g          = not install in this project but globally on your machine

install express.Js  = npm install --save express
--save = used in a production dependency

--save-dev = used tool during development 

Middleware means that an incoming request automatically funneled through a bunch of functions by express.js



Framework: Helper functions, tools and rules that help you build your application!


Send File or to serve a HTML page we use
sendFile()   =   send back a file to the user

an absolute path would be correct but / like this actually refers to our root folder on our operating system not to this project folder.

so in order to construct path to the directory and to the file, we can use a feature provided by node.js another core module.

const path = reqiuring('path')    => we can send the with the help of path create by this module by calling th join() method.



res.sendFile(path.join(__dirname,'views', 'shop.html'));
it works on both linux and windows system
Path join basically detects the operating system you are running on and then automatically builds the correct path.

router.get("/", (req, res, next) => {
  res.sendFile(path.join(__dirname, "../", "views", "shop.html"));
});

const path = require('path')   => to get the file location 


USING A HELPER FUNCTION FOR NAVIGATION

dirname()   = return the directory name of a path


const path = require("path");

module.exports = path.dirname(process.mainModule.filename);
this gives us the path to the file that is responsible for the fact that our application is running
and this filename is what we put into dirname to get a path to that directory.


STYLING OUR PAGES ==== CSS

SERVING FILES STATISCALLY

we need to be serve file statically and statically means not handled not handled by the express router or some othe middleware but instead directly forwarde to the file system
 
And for this, we register a new middleware with app use and this is one express.js ships with, we use express object itself and this does have a static middleware and this is a built in middleware

app.use(express.static(path.join(__dirname, "public")));

MODULE SUMMARY
Express.js == is node.js framework - a package that adds a bunch of utility functions that adds a bunch of utility functions and tools and a clear set of rules on how the apps should be built (middleware)
It's highly extensible and other packages can be plugged into it(middleware) 

MIDDLEWARE, next() and res()
Express.js relies heavily on middleware functions- you can easily add them by calling use()
Middleware functions handle a request and should call next() to forward the request to the next function in line or send a response


ROUTING
you can filter request by path and method
if you filter by method,paths are matched exactly, otherwise, the first segment of URL is matched
You can use the express.Router to split your routes across files elegantly

SERVE FILES
you are not limited to serving DUMMY text as a response
You can sendFile()s to your user - e.g. HTML files
If a request is directly made for a file (e.g. a .css file is requested), you can enable static serving for such files via express.static()


WORKING WITH DYNAMIC CONTENT AND ADDING TEMPLATING ENGINES

Managing Data(without a Database)
Render Dynamic Content in our views
Understanding Templating Engines

SHaring Data Across Request And Users

Templating Engines

Available Templating Engines

EJS          <p><%=name %></p>      Use normal HTML and plain javascript in your templates

Pug           p  #{name}            Use minimal HTML and custom template language 
 
Handlebars   <p>{{ name }}</p>      Use normal HTML and custom template language



Installing and Implementing Pug

Install all three

npm install --save ejs pug express-handlebars        =   production dependency

you can install multiple packages by simply repeating or by adding all the names after npm install 



PUG

app.set();     = app.set() allows us to set any value globally on our express application


ADDING A LAYOUT

Use Dynamic Content from temlating engines

WORKING WITH HANDLEBARS

Due to a (temporary) breaking change introduced by the library authors (of the package we'll install in the next lecture), make sure you run 
    npm install --save express-handlebars@3.0

app.engine = engine method this registers a new templating engine in case we're using one which is not built-in, pug was built-in kind of, express handlebars is not
  to register this, we have to define a name for our engine 

const app.engine("handlebars", expressHbs());
app.set("view engine", "handlebars");
app.set("view engine", "pug");
app.set("views", "views");


CONVERTING OUR PROJECT TO HANDLEBARS

Extension name which only applies to the layout and not to all files


// WORKING WITH EJS
Now ejs is a templating engine which is just like pug, supported out of the box so we don't need

to register the engine as we did it with handlebars,
ejs does not support layouts but we will find a solution to at least have some kind of reusability

// WORKING ON THE LAYOUTS WITH PARTIALS
	We can do this combined with a keyword offered by ejs,

the include keyword which allows us to include a certain element into this page and then you close that

with the normal ejs tag, without the minus.

Now here in include, you simply add a string which holds the path to the file you want to include and

you have to enter this path as it's seen from the file you're in,



// WRAP UP


/// MVC  ( MODEL VIEW CONTROLLER )


MODELS
. Represent your data in your code
.work with your data (e.g. save,fetch)
                                     
VIEWS 
. What the user sees
. Decoupled from your application code
                               
CONTROLLERS  ---- Routes   --- Split across Middleware functions
. connecting your Models and Your Views
. Contain the "in-between"  logic


// ADDING CONTROLLERS
// FINISHING THE CONTROLLERS

// ADDING A PRODUCT MODEL


// STORING DATA IN FILES VIA THE MODEL

we need to be able to work with the file system,

so I will import fs from the core fs module.

Now that file should then also be created in special path, so I will use the path tool,

the path module to construct a path that works on all operating systems.

Now here in save, I will then create my path and I will do that with path join,

so using the path core module, whoops,

and I name this p so that I avoid namespace clashes and the path should be my root directory.

you can create a read stream with this function but we can read the entire file here,


/ and I will put my json data into it,

so again I will use that json helper object

and now there is the stringify find method which takes a javascript object or array and converts it

into json

so that this has the right format,

so there I will take this products array and convert this to json

and then this gets written to the file.

// FETCHING DATA FROM FILES VIA MODEL

// REFACTORING THE FILE STORAGE CODE

// MODULE SUMMARY

  MODEL => model serves the purpose

of representing our data and of managing our data, saving it, fetching it, later also updating it and so

on. And it doesn't matter if you manage your data in memory, files or databases,

it is the model which is responsible for your data,

it contains all the data related logic.

VIEW => The view on the other hand is responsible for presenting it to the user, is responsible for what the

user sees and it shouldn't contain too much logic which might remind you of the handlebars templating


CONTROLLER => Connects Model and View
	Should only make sure that the two can communicate (in both directions) 


/// [TIMESTAMP IN DESCRIPTION]  - SSR and Client side Rendering 

chrome as a browser, IT only understands HTML, CSS and JAVASCRIPT.



// CLIENT SIDE RENDERING
angular, React and plain javascript all are client side rendering

Your Html css and js - it gets completely downloaded.

Disadvantage - first load is heavy, but it get cached for next time.


/// OPTIONAL : ENHANCING THE APP

// Creating the shop structure
  ***   ../   means up one level

// create two new subfolder in views folder
//  shop and admin folder
// then add some files in shop folder- cart.ejs, index.ejs, product-detail.ejs, and product-list.ejs
// and in admin folder we create files like - add-product.ejs, edit-product.ejs and product.ejs 



/// Registering the routes

when we click on add product the next function will be add through routes or links add through routes

// routes helps to get path to that file through link or address

//  I will add

a new get route because I want to load a new page and that will just be /products.

// So now we might be back to actually using a shop controller and a new admin controller so that we can
split our logic by these two sections,

// I will export a new page and that should be my get index function

// We also need to load the cart and checkout pages and therefore let's go back to the shop controller

// we see that the path is not defined,

so what I'm missing here is that for my 404 controller, the error controller to be precise,

I also need to add a path here because I try to extract that path in my navigation and therefore I

also should set the path here and I can set it to /404,


/// STORING THE PRODUCT DATA

// So now we got all these fields here which we need to add a product

and these are automatically added to the request which is sent to the backend because we are using regular

html inputs in a form and we assigned names,

so now we can extract all that data up by the names we assign to our input fields here.

//and now we create a product with all that data.

Now with that, in the next step, let's also extract that data and show it when we show all products.



///  DISPLAYING PRODUCT DATA

// Now you can press add products and right now this does not support decimal numbers, to fix this,

we can change something in the add product view, there on the number input

we simply have to add a step attribute and set the step to 0.01,

this means you can have well two decimal places essentially and increment in this step size.

/// EDITING AND DELETING PRODUCTS

// a == anchor tag is used in html to add a link

/// ADDING ANOTHER ITEM

*****
Attached, you find the source code for this section.

When using my source code, make sure to run npm install in the extracted folder!

// To get in deep with MVC
 =----   https://developer.mozilla.org/en-US/docs/Glossary/MVC


////  DYNAMIC ROUTES AND ADVANCE MODELS


/// module intro
//  Passing route Params
//Using Query Params
// Enhance our Models


///Applied Changes
What changed in the attached files?

Basically, a mobile navigation (for smaller/ mobile screens) was added. Besides that, only minor things were fixed.

/// ADDING THE PRODUCT ID TO THE PATH

//* I'll add a new property

by writing this ID

and this adds a new property to the entire product object we're working on

// Now we just want to make sure that we of course then also are able to handle that and extract

that unique ID from the path in our routes file

so that we

or in the controller, so that we can load the correct product and show the details for it

and that is the whole idea here.

We send some information as part of the path so that we can extract all the data we need for the product


/// EXTRACTING DYNAMIC PARAMS
**** VERY IMPORTANT 

//we can get access to it by accessing our request and then expressjs already gives us a params

object on our request

and on that params object, we can access our product ID and we can access product ID here because we

use product ID in our route shop.js file as a name after the colon.



/// *** LOADING PRODUCT DETAIL DATA

//I can find it

by searching products with the find method, a default javascript method,

this will execute a function we pass to find on every element in the array and we'll return the element

for which this function we pass returns true.

So this function we pass here will get

the product it's currently looking at because it executes it for all the products in the array.



//// **** RENDERING PRODUCT DETAIL VIEW



////**** Passing Data WITH POSt  REQUEST


//  However here, I will send a post request right,

add to cart sends a post request and this has one important implication,

we can pass data in the request body.

This was not possible for a get request but for post request you typically use the request body,

this is also what we use when adding a product. For adding a product,

we have a form and as I mentioned there when we added this the first time in the course, this automatically

gives us a request which puts all the input data and so on into its body

but this only works for posting data,

this is not available for getting data but for posting data,

//  we can also add an include add

to cart ejs and put that entire code into that include here and then simply well include that include.

So instead of having that code here in index.ejs, we can use the ejs tag with the minus to add include

and then we go to well up one level and then into includes and then add to cart and we use that

same code also in the product detail page here and also in the product list page.

So there I also want to replace this form with my include.





//// *****ADDING A CART MODEL

// Add a new model here cart.js
// cart is like a separate entity in our project.
//  we have to think about how we want to manage that cart.

Now obviously we want to have a cart that holds all the products that we added

and we also want to group products by id and increase their quantity in case we add a product more

than once.

So to do all of that, I will first of all create a constructor here which allows us to create a new cart.


//Now what we need on this cart though is a way to add and remove our products

obviously. Now the problem we have is the cart itself is not really an object we'll constantly recreate,

not for every new product that we add we want to have a new cart, instead there always will be

a cart in our application and we just want to manage the products in there

//*  I don't really add a constructor instead I'll add a static method, add product like this.

Now this will take the ID of the product I want to add and the goal here will be to then fetch the

old or previous cart from our file for now, analyze that and see if we already have that product,

find existing product and then add new product or increase the quantity


//// USING QUERY PARAMS  
//   I want to render the same form I have for add-product.

The difference will be that I want to pre-populate that form

with the values of the product I wanna edit.

Now, if I'm using the same HTML code in the end,

it would make sense to reuse the same template.

If you ever plan on using a different one,

it doesn't, but here it makes sense.

So what I'll do is I'll take my add-product.ejs code

and move it into edit-product

because I find this to be the more generic name

and I'll delete the add-product.ejs file.

So now we just have edit-product.ejs

with all the HTML code in there that we need.

// we delete the add-product.js file

//But let's say we want to get an additional confirmation

by ensuring that people have to pass us

a so-called query parameter in the URL.

A query parameter can be added to any URL

by adding a question mark

and then a key-value pair, separated by an equal sign,

like edit equals true.

And you can have multiple query parameters

by separating them with ampersands.

So we could also have title equals new, for example.

So this is possible

and this is so-called optional data.

The path here, the route which gets reached

is determined by the part up to the question mark.

So you don't need to add any information

about query parameters you might get

to your routes file.

These paths are not affected.

But you can always check for query parameters

in your controllers.

So here we can check if const editMode,

if this is set by going to our request

and there will be a query object.

This is also created and managed by Express.js.

And you can access your data here

by simply trying to access the keys you got

in your query parameters.
// query object is also created and managed by express.js

// Important: The extracted value always is a string!  So "true" instead of true.




//// **** PRE POPULATING THE EDIT PRODUCT PAGE WITH DATA



////**** LINKING THE EDIT PRODUCT PAGE


////****  EDiting the product Data



